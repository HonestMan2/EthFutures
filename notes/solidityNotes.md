#Notes on Solidity#

##Layout of a Solidity Source File##

###Version Pragma###

 - Source files can be annotated with a **version pragma** that defines the compiler version that must be used to compile the contract
 - Can be written as `pragma solidity ^0.4.0;`
 - Expressions follow the same format as used by npm

###Importing other Source Files###
####Syntax and Semantics####

 - Import statements follow a layout similar to that in Javascript
 - Global imports: `import "filename"`

####Paths####

 - `filename` is always treated as a path with `/` as directory separator, `.` as the
   current and `..` as the parent directory.
 - Path names that do not start with `.` are treated as absolute paths.

###Comments###

 - Single line comments (`//`) and multi-line comments (`/*...*/`) 
 - Natspec comments, written with a triple slash (`///`) or a double asterisk block (`/**
   ... */`) and should be used directly above function declarations or statements

##Structure of a Contract - Summary##

###State Variables###

 - Values that are permantently stored in contract storage

```javascript
pragma solidity ^0.4.0;

contract SimpleStorage {
	uint storedData; // State variable
	// ...
}
```

###Functions###

 - Functions are the executable units of code within a contract

```javascript
pragma solidity ^0.4.0;

contract SimpleAuction {
	function bid() payable {
		// ...
	}
}
```

 - Function calls can happen internally or externally and have different levels of
   visibility

###Function Modifiers###

 - Function modifiers are used to amend the semantics of functions 

```javascript
pragma solidity ^0.4.0;

contract Purchase {
	address public seller;
	
	modifier onlySeller() { / Modifier
		if (msg.sender != seller) throw;
		// ...
	}

	function abort() onlySeller { // Modifier usage
		// ...
	}
}
```

###Events###

 - Convenience interfaces with the EVM logging facilities

```javascript
pragma solidity ^0.4.0;

contract SimpleAuction {
	event HighestBidIncreased(address bidder, uint amount); // Event
	
	function bid() payable {
		// ...
		HighestBidIncreased(msg.sender, msg.value); // Triggering event
	}
}
```
###Structs Types###

 - Structs are custom defined types that can group several variables

```javascript
pragma solidity ^0.4.0;

contract Ballot {
	struct Voter { // Struct
		uint weight;
		bool voted;
		address delegate;
		uint vote;
	}
}
```
***

##Contracts##

###Creating Contracts###

 - Contracts are creatable from "outside" or from other Solidity contracts
 - Upon contract creation, its constructor is executed once
 - From `web3.js` - the JavaScript API - this is done as below:

```javascript
// Need to specify some source including contract name for the data param below
var source = "contract CONTRACT_NAME { function CONTRACT_NAME(unit a, uint b) {} }":

// The json abi array generated by the compiler
var abiArray = [
	{
		"inputs":[
			{"name":"x","type":"uint256"},
			{"name":"y","type":"uint256"}
		],
		"type":"constructor"
	},
	{
		"constant":true,
		"inputs":[],
		"name":"x",
		"outputs":[{"name":"","type":"bytes32"}],
		"type":"function"
	}
];

var MyContract_ = web3.eth.contract(source);
MyContract = web3.eth.contract(MyContract_.CONTRACT_NAME.info.abiDefinition);
// Deploy new contract
var contractInstance = MyContract.new(
	10,
	11,
	{from: myAccount, gas: 1000000}
);
```

 - If using `web3.js` you do not need to worry about the constructor arguments being passed after the code of the constructor
   itself

 - If a contract wants to create another contract, the source code of the created contract must known to the creator, thereby
   preventing cyclic creation dependencies

##Visibility and Accessors##

###Visibility###

 - Solidity allows 4 types of visibilities for functions and state variables
    - `external`
        - Part of the contract interface
        - Can be called from other contracts and via transactions
        - An external function `f` cannot be called internally - e.g. `f()` does not work, but `this.f()` does
    - `public`
        - Part of the contract interface and can be called either by messages or internally
    - `internal`
        - Functions that can only be called internally/within the contract
    - `private` 
        - Private functions and state variables are only visible within the contract they are defined and not in derived
	  contracts
###Accessor Functions###

 - The compiler automatically creates accessor functions for all **public** state variables
 - Accessor functions have external visibility
     - If the function is accessed internally (without the `this`) it is evaluated as a state variable
     - If it is accessed externally (i.e. with `this`) it is evaluated as a function

##Fallback Function##

 - A contract can have **exactly one** unnamed function
 - This function cannot have arguments nor can it return anything 
 - Executed when none of the other functions matches the given funciton identifier or if no data was supplied at all
 - Also executed if the the contract receives just Ether
 - Very little gas available to the fallback function (2300 gas) so ned to be simple
 - Specific functions that will consume more gas than the fallback function is given:
     - Writing to storage
     - Creating a contract
     - Calling an external function which consumes a large amount of gas
     - Sending Ether

***
##Expressions and Control Strucutres##
###Control Structures###

 - Most usual control structures from C/Javascript are available in Solidity except for `switch` and `goto`
 - Note that there is **no** type conversion from non-boolean to boolean types like in C or Javascript
    - e.g. `if (1) { ... }` is *not* valid in Solidity

###Function Calls###
####Internal Function Calls####

 - Functions of the current contract are able to be called directly (i.e. *internally*) as well as recursively
 - Within the EVM, these calls are transalted into simple jumps
     - This has the impact that current memory is not cleared - passing memory references to internally-called functions is very
       efficient
 - Only functions of the same contract can be called internally

####External Function Calls####

 - External function calls (i.e. calling functions of one contract from another contract) are done via *messages* instead of a
   direct jump
 - For an external call, all the arguments of the function must be passed into memory
 - The gas and amount of Wei sent with an external call can be specified:

```javascript
contract InfoFeed {
	function info() payable returns (uint ret) { return 42; }
}

contract Consumer {
	InfoFeed feed;
	function setFeed(address addr) { feed = InfoFeed(addr); }
	funciton callFeed() { feed.info.value(10).gas(800); } // Specifying the Wei and gas sent when calling InfoFeed
}
```

 - Note that in the above example, the modifier `payable` has to be used for `info` as otherwise it would not be possible to
   send Ether to it so as to call `feed.info.value(10).gas(800)()`.
 - Note also that `InfoFeed(addr)` performs an **explicit** type converstion that states "we know that the contract type being
   passed at the given address is `InfoFeed`" and that this contract does not execute a constructor
    - Never call a function on a contract when you are unsure about its type
 - Function calls cause exceptions if the contract being called does not exist (i.e. has no code)
 - Will also throw an exception if the contract itself throws an exception or runs out of gas

**Warning**

 - Interaction with other contracts always impose a danger due to loss of control
 - Write functions such that calls to external functions happen after any changes to state variables 
 - This is to prevent vulnerability to a reentry exploit

####Named Calls and Anonymous Function Parameters####


***
##Code Samples##

###Voting Contract###

Idea is to create one contract per ballot, providing a short name for each option. Then the creator of the contract, who serves a chairperson, will give the right to vote to each address (the participants) individually.

At the end of the voting, the `winningProposal()` will return the proposal with the largest number of votes.

```javascript
// From the voting example, winningProposal() extract

function winningProposal() constant
	returns (uint winningProposal)
{
	uint winningVoteCount = 0;
	for (uint p = 0; p < proposals.length; p++) {
		if (proposals[p].voteCount > winningVoteCount) {
			winningVoteCount = proposals[p].voteCount;
			winningProposal = p;
		}
	}
}
```

###Open Auction###

Idea is to create a contract that everyone can send their bids during a bidding period where the bids include sending
money/ether to bind the bidders to their bids. Should the highest bid be raised, the previously highest bidder gets their money
back. Once the bidding period ends, the contracts has to be called manually for the beneficiary to receive their money.

```javascript
// From the open Auction example 

function auctionEnd() {

	// 1. Conditions
	if (now <= auctionStart + biddingTime)
		throw; // auction did not yet end
	if (ended)
		throw; // this function has already been called
	
	// 2. Effects
	ended = true;
	AuctionEnded(highestBider, highestBid);

	// 3. Interaction
	if (!beneficiary.send(highestBid))
		throw;
}
```

Good idea to structure functions that interact with other contracts into three phases:

 1. Checking conditions
 2. Performing actions (potentially changing conditions)
 3. Interacting with other contracts

The danger is that if these steps are mixed up, the other contract could call back into the current contract and modify the
state or cause effects (e.g. Ether payout) to be performed multiple times.

If functions called internally include interaction with external contracts, they also have to be considered interaction with
external contracts
